# -*- coding: utf-8 -*-
"""consent_parser.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P-hrOB1n3fwhDeJSnAdxxrfTmILfdQ5a
"""


import os, re, json, pdfplumber

# -----------------------------
# FOLDER SETUP
# -----------------------------
pdf_folder = "medical_pdfs/consents"
parsed_text_folder = "parsed_texts"
json_output_folder = "json_consents"

os.makedirs(pdf_folder, exist_ok=True)
os.makedirs(parsed_text_folder, exist_ok=True)
os.makedirs(json_output_folder, exist_ok=True)

# -----------------------------
# STEP 1: PDF → TEXT
# -----------------------------
for filename in os.listdir(pdf_folder):
    if filename.lower().endswith(".pdf"):
        pdf_path = os.path.join(pdf_folder, filename)
        text_path = os.path.join(parsed_text_folder, f"{os.path.splitext(filename)[0]}.txt")

        print(f"Parsing {filename}...")
        with pdfplumber.open(pdf_path) as pdf:
            all_text = ""
            for i, page in enumerate(pdf.pages):
                text = page.extract_text() or ""
                all_text += f"\n--- Page {i+1} ---\n{text}\n"

        with open(text_path, "w", encoding="utf-8") as f:
            f.write(all_text)

        print(f"✅ Saved parsed text to {text_path}\n")

print("All PDFs parsed.\n")

# -----------------------------
# BASE SCHEMA
# -----------------------------
def base_schema():
    return {
        "patient_name": None,
        "patient_first_name": None,
        "patient_middle_name": None,
        "patient_last_name": None,
        "patient_address_name": None,
        "patient_id": None,
        "patient_dob": None,
        "patient_signature": None,
        "patient_state": None,
        "patient_city": None,
        "patient_zip_code": None,
        "provider_name": None,
        "provider_address_name": None,
        "provider_phone": None,
        "provider_fax": None,
        "provider_state": None,
        "provider_city": None,
        "provider_zip_code": None,
        "family_name": None,
        "family_relation": None,
        "family_phone": None,
        "family_address_name": None,
        "family_state": None,
        "family_city": None,
        "family_zip_code": None,
        "guardian_name": None,
        "guardian_signature": None,
        "guardian_relation": None,
        "date": None,
        "expiration_date": None,
        "expiration_event": None,
        "translator_name": None,
        "translator_signature": None
    }

US_STATES = {
    "Alabama", "Alaska", "Arizona", "Arkansas", "California", "Colorado", "Connecticut",
    "Delaware", "Florida", "Georgia", "Hawaii", "Idaho", "Illinois", "Indiana", "Iowa",
    "Kansas", "Kentucky", "Louisiana", "Maine", "Maryland", "Massachusetts", "Michigan",
    "Minnesota", "Mississippi", "Missouri", "Montana", "Nebraska", "Nevada", "New Hampshire",
    "New Jersey", "New Mexico", "New York", "North Carolina", "North Dakota", "Ohio",
    "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina", "South Dakota",
    "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington", "West Virginia",
    "Wisconsin", "Wyoming"
}

def parse_city_state_zip(line):
    words = line.strip().split()

    if not words:
        return "", "", ""

    # Check if last word is numeric → assume ZIP
    if words[-1].isdigit():
        zip_code = words[-1]
        remaining = words[:-1]
    else:
        zip_code = ""
        remaining = words

    # Try last two words as a state (for states like "North Dakota")
    if len(remaining) >= 2 and " ".join(remaining[-2:]) in US_STATES:
        state = " ".join(remaining[-2:])
        city = " ".join(remaining[:-2])
    # Try last word as state
    elif remaining[-1] in US_STATES:
        state = remaining[-1]
        city = " ".join(remaining[:-1])
    else:
        state = ""
        city = " ".join(remaining)

    return city.strip(), state.strip(), zip_code.strip()


def assemble_patient_name(first, middle, last):
    """
    Build the patient_name field using only first and last names.
    Normalizes N/A and similar values to None.
    """
    def clean(value):
        if not value:
            return None
        val = value.strip()
        return None if val.upper() in ["N/A", "NA", "NONE", "N.A.", "N.A", "NULL"] else val

    first, middle, last = clean(first), clean(middle), clean(last)

    if first and last:
        full_name = f"{first} {last}"
    elif first:
        full_name = first
    elif last:
        full_name = last
    else:
        full_name = None

    return {
        "patient_name": full_name,
        "patient_first_name": first,
        "patient_middle_name": middle,
        "patient_last_name": last
    }


# -----------------------------
# PARSER
# -----------------------------
def parse_nih_consent(text):
    c = base_schema()

    # --- Provider ---
    provider_match = re.search(r"NAME\s+PHONE\s*\n([A-Za-z\s\.]+)\s+([\+\d\.-]+)", text)
    if provider_match:
        c["provider_name"] = provider_match.group(1).strip()
        c["provider_phone"] = provider_match.group(2).strip()

    addr_match = re.search(r"ADDRESS\s+FAX\s*\n(.+)\n([\d\-\+]+)", text)
    if addr_match:
        c["provider_address_name"] = addr_match.group(1).strip()
        c["provider_fax"] = addr_match.group(2).strip()

    # --- City / State / ZIP ---
    loc_match = re.search(r"CITY STATE ZIP\s*\n(.+)\n(\d{4,5})", text)
    if loc_match:
        city_state_line = loc_match.group(1).strip()
        zip_code = loc_match.group(2).strip()

        words = city_state_line.split()
        last_two = " ".join(words[-2:])
        last_one = words[-1]

        if last_two in US_STATES:
            state = last_two
            city = " ".join(words[:-2])
        elif last_one in US_STATES:
            state = last_one
            city = " ".join(words[:-1])
        else:
            state = ""
            city = city_state_line  # fallback

        c["provider_city"] = city.strip()
        c["provider_state"] = state.strip()
        c["provider_zip_code"] = zip_code


    # --- Patient Name ---
    pat_line = re.search(r"1\.\s*NAME OF PATIENT.*?\n([A-Za-z\s]+)", text)
    if pat_line:
        full_name = pat_line.group(1).strip()
        name_parts = full_name.split()
        c["patient_name"] = f"{name_parts[0]} {name_parts[1]}" if len(name_parts) >= 2 else full_name

    # --- Patient Signature ---
    sig_match = re.search(r"7\.\s*SIGNATURE OF PATIENT.*?\n([A-Za-z\s]+?)(?:\s+N/A|\s*$)", text)
    if sig_match:
        c["patient_signature"] = sig_match.group(1).strip()

    # --- Date ---
    date_match = re.search(r"9\.\s*DATE OF SIGNATURE\s*\n(\d{4}-\d{2}-\d{2})", text)
    if date_match:
        c["date"] = date_match.group(1)

    # --- Expiration Date ---
    exp_match = re.search(r"FROM\s+\d{4}-\d{2}-\d{2}.*?TO\s+(\d{4}-\d{2}-\d{2}|N/A)", text, re.DOTALL)
    if exp_match:
        exp_val = exp_match.group(1).strip()
        c["expiration_date"] = exp_val if exp_val != "N/A" else None
        c["expiration_event"] = None

    return c


def parse_hipaa_consent(text):
    c = base_schema()

    # --- Patient Name ---
    pat_name = re.search(r"Last Name:\s*(\S+)\s*First Name:\s*(\S+)\s*Middle Name:\s*(\S+)", text)
    if pat_name:
        last, first, middle = pat_name.groups()
        name_fields = assemble_patient_name(first, middle, last)
        c.update(name_fields)

    # --- DOB ---
    dob_match = re.search(r"Date of Birth:\s*(\d{4}-\d{2}-\d{2})", text)
    if dob_match:
        c["patient_dob"] = dob_match.group(1)

    # --- Patient ID ---
    pat_id = re.search(r"Reference Nº:\s*(\S+)", text)
    if pat_id:
        c["patient_id"] = pat_id.group(1)

    # --- Address ---
    addr_match = re.search(r"Address:\s*(.+)\nCity/State/ZIP:\s*(.+)/(.+)/(\d{4,5})", text)
    if addr_match:
        c["patient_address_name"], c["patient_city"], c["patient_state"], c["patient_zip_code"] = addr_match.groups()

    # --- Provider Info (Scoped to Section 2) ---
    prov_block = re.search(r"Section 2.*?(?=Section 3)", text, re.S)
    if prov_block:
        block = prov_block.group(0)

        prov_name = re.search(r"Name:\s*(Dr\.\s+[A-Z][a-z]+\s+[A-Z][a-z]+)", block)
        if prov_name:
            c["provider_name"] = prov_name.group(1).strip()

        prov_addr = re.search(
            r"Address:\s*(.+?)\nCity/State/ZIP:\s*([A-Za-z\s]+)/([A-Za-z\s]+)/(\d{4,5})",
            block
        )
        if prov_addr:
            c["provider_address_name"], c["provider_city"], c["provider_state"], c["provider_zip_code"] = [
                g.strip() for g in prov_addr.groups()
            ]

    # --- Family / Recipient ---
    fam_match = re.search(
        r"Section 3.*?Name:\s*(.+)\nRelationship.*:\s*(.+)\nTelephone.*:\s*(.+)\nAddress:\s*(.+)\nCity/State/ZIP:\s*(.+)/(.+)/(\d{4,5})",
        text, re.S)
    if fam_match:
        (c["family_name"], c["family_relation"], c["family_phone"],
         c["family_address_name"], c["family_city"], c["family_state"], c["family_zip_code"]) = [s.strip() for s in fam_match.groups()]

# --- Expiration (robust to newlines / broken hyphens) ---
    # Try to capture "Expiration Event" first (unchanged)
    exp_event = re.search(r"Expiration Event:\s*(.+?)\s*Expiration Date:", text)

    # Robust capture for expiration date that handles line breaks like "2026-10-\n27"
    exp_date_parts = re.search(
        r"Expiration Date:\s*(\d{4})\s*[-\s]*\s*(\d{1,2})\s*[-\s]*\s*(\d{1,2}|N/A)",
        text,
        re.S
    )
    if exp_date_parts:
        y, m, d = exp_date_parts.groups()
        if d and d.upper() != "N/A":
            # normalize to zero-padded YYYY-MM-DD
            c["expiration_date"] = f"{y}-{m.zfill(2)}-{d.zfill(2)}"
        else:
            c["expiration_date"] = None

    # keep the existing logic to set expiration_event from exp_event if needed
    if exp_event:
        val = exp_event.group(1).strip()
        if val.upper() not in ["N/A", "NA"]:
            c["expiration_event"] = val

    # --- Signature (Section 10) ---
    sig_match = re.search(r"Section 10.*?Signature:\s*([A-Za-z\s]+)\s*Date:\s*(\d{4}-\d{2}-\d{2})", text, re.S)
    if sig_match:
        c["patient_signature"], c["date"] = [x.strip() for x in sig_match.groups()]

    # --- Translator Info ---
    translator = re.search(
        r"Name of translator \(if applicable\):\s*(.+)\s*Signature of translator \(if applicable\):\s*(.+)",
        text
    )
    if translator:
        name, sig = translator.groups()
        if name.upper() not in ["N/A", "NA"]:
            c["translator_name"] = name.strip()
        if sig.upper() not in ["N/A", "NA"]:
            c["translator_signature"] = sig.strip()

    return c

# -----------------------------
# STEP 2: TEXT → JSON
# -----------------------------
for filename in os.listdir(parsed_text_folder):
    if not filename.endswith(".txt"):
        continue

    path = os.path.join(parsed_text_folder, filename)
    with open(path, "r", encoding="utf-8") as f:
        text = f.read()

    # Detect which template
    if "NIH Occupational" in text:
        template = "nih_consent"
        parsed = parse_nih_consent(text)
    elif "HIPAA Authorization Form" in text:
        template = "hipaa_consent"
        parsed = parse_hipaa_consent(text)
    else:
        template = "unknown"
        parsed = base_schema()
        parsed["error"] = "Unknown consent template"

    out_path = os.path.join(json_output_folder, f"{os.path.splitext(filename)[0]}_{template}.json")
    with open(out_path, "w", encoding="utf-8") as f:
        json.dump(parsed, f, indent=2)

    print(f"✅ Parsed {filename} as {template} → {out_path}")

print("All consents processed.")

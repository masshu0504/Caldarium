from fastapi import APIRouter, File, UploadFile, HTTPException
from fastapi.responses import JSONResponse
import psycopg2
from datetime import datetime
from parser_prototype import preprocess_text, clean_and_convert, extract_fields, extract_line_items, parse_invoice, parse_pdf_bytes
import os
from pathlib import Path
from dotenv import load_dotenv
from typing import Any, Dict
import pdfplumber, re, json
from io import BytesIO


env_path = Path('.') / '.env.example'

load_dotenv(dotenv_path=env_path)


routes = APIRouter()

@routes.get("/health")
async def health():
    return {"status": "OK"}


@routes.get("/ready")
async def ready():
    try:
        
        conn = psycopg2.connect(
            host=os.getenv("POSTGRES_HOST"),
            port=os.getenv("POSTGRES_PORT"),
            dbname=os.getenv("POSTGRES_DB"),
            user=os.getenv("POSTGRES_USER"),
            password=os.getenv("POSTGRES_PASSWORD")
        )
        cur = conn.cursor()
        cur.execute("SELECT 1;")  # simple query
        result = cur.fetchone()
        cur.close()
        conn.close()
        if result == (1,):
            return {"status": "DB connection OK"}
        else:
            return {"status": "DB connection failed"}
    except Exception as e:
        return {"status": f"DB connection failed", "error": str(e)}
    


DB_HOST = os.getenv("POSTGRES_HOST")
DB_PORT = os.getenv("POSTGRES_PORT")
DB_NAME = os.getenv("POSTGRES_DB")
DB_USER = os.getenv("POSTGRES_USER")
DB_PASS = os.getenv("POSTGRES_PASSWORD")

def get_db_connection():
    """Establishes and returns a psycopg2 database connection."""
    return psycopg2.connect(
        host=DB_HOST,
        port=DB_PORT,
        dbname=DB_NAME,
        user=DB_USER,
        password=DB_PASS
    )


def insert_data(data: Dict[str, Any], table: str = "parsed_data") -> str:
    """
    Inserts data into the specified PostgreSQL table and returns the generated ID.
    
    Assumes a table structure like:
    CREATE TABLE parsed_data (
        id UUID PRIMARY KEY,
        created_at TIMESTAMP WITH TIME ZONE,
        extracted_data JSONB
    );
    """
    conn = None
    generated_id = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # SQL to insert the extracted JSON data, capture the generated UUID, and 
        # use the database's clock for the timestamp (NOW()) for consistency.
        sql = f"""
        INSERT INTO {table} (id, created_at, extracted_data)
        VALUES (gen_random_uuid(), NOW(), %s)
        RETURNING id;
        """
        
        # Use str(data) or json.dumps(data) if you were to use the actual JSON type.
        # Since we are just inserting a single JSON object, passing the dict directly 
        # often works if psycopg2 is configured, but casting to string/JSON is safer.
        import json
        json_data = json.dumps(data)
        
        cursor.execute(sql, (json_data,))
        
        # Fetch the ID that was generated by the database
        generated_id = cursor.fetchone()[0]
        
        conn.commit()
        cursor.close()
        return str(generated_id)
        
    except psycopg2.Error as e:
        if conn:
            conn.rollback()
        print(f"Database error during insert: {e}")
        # Re-raise the exception to be caught by the FastAPI route's handler
        raise
        
    finally:
        if conn:
            conn.close()


    
@routes.post("/v1/parse")
async def parse(file: UploadFile = File(...)):
    try: 
        filename = file.filename
        content_type = file.content_type

        # uses parser*
        contents = await file.read()
        data = parse_pdf_bytes(contents)

        size = len(contents)
        # change after getting parser
        
        invoice_number = data["invoice_number"]
        #patient_id = 0
        subtotal_amount = data["subtotal_amount"]
        invoice_date = data["invoice_date"]
        total_amount = data["total_amount"]
        line_items = data["line_items"]

        due_date = data["due_date"]
        patient_name = data["patient_name"]
        patient_age = data["patient_age"]
        patient_address = data["patient_address"]
        patient_phone = 0
        patient_email = 0
        admission_date = data["admission_date"]
        discharge_date = data["discharge_date"]
        discount_amount = data["discount_amount"]
        bed_no = 0
        provider_name = 0
        provider_email = 0
        provider_website = 0
        account_no = 0
        hospital_no = 0
        bed_no = 0
        consultant = 0
        billed_to_address = 0
        tax_percent = data["tax_percent"]
        tax_amount = 0
        currency = 0
        payment_instructions = 0
        disclaimer = 0
        total_amount = data["total_amount"]



        extracted_data = {
            "invoice_number": invoice_number,
            "subtotal_amount": subtotal_amount,
            "invoice_date": invoice_date,
            "total_amount": total_amount,
            "line_items": line_items,
            "patient_name": patient_name,
            "patient_age": patient_age,
            "patient_address": patient_address,
            "admission_date": admission_date,
            "discharge_date": discharge_date,
            "discount_amount": discount_amount,
            "tax_percent": tax_percent,
            "due_date": due_date,
            "file_metadata": {
                "original_filename": filename,
                "file_size_bytes": size,
                "content_type": content_type
            }
        }

        if (invoice_number is None and
        subtotal_amount is None and
        invoice_date is None and
        total_amount is None and
        line_items is None and
        patient_name is None and
        patient_age is None and
        patient_address is None and
        admission_date is None and
        discharge_date is None and
        discount_amount is None and
        tax_percent is None and
        due_date is None):
            return JSONResponse(
                status_code=422,
                content={
                    "status" : "failed to extract all required fields", 
                    "error": 422
                }
            )
        else:
            inserted_id = insert_data(data=extracted_data)
            
            # Return Success Response ---
            return {
                "status": "success",
                "message": "File parsed and data stored successfully.",
                "db_id": inserted_id,
                "extracted_data": extracted_data # Return the data to confirm storage
            }
        
    except psycopg2.Error as e:
        # Handle PostgreSQL specific errors
        print(f"PostgreSQL Error: {e}")
        return JSONResponse(
            status_code=500,
            content={"status": "error", "message": "A database error occurred during storage."}
        )
    except Exception as e:
        # Handle general errors (file read error, JSON parsing error, etc.)
        print(f"General Error: {e}")
        return JSONResponse(
            status_code=500,
            content={"status": "error", "message": f"An unexpected error occurred: {str(e)}"}
        )



# -*- coding: utf-8 -*-
"""audit_logger.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GsKgT66kvZ1O-zTJk2Z8LLreKqm6DFA_
"""

import json
import uuid
from datetime import datetime, timezone

# Allowed values per role
ROLE_ACTIONS = {
    "api": {
        "actions": {
            "upload_pdf", "run_start", "store_parser_output",
            "store_final_json", "run_end", "export"
        },
        "statuses": {"success", "fail"},
        "meta_keys": {"parser_version"}
    },
    "parser": {
        "actions": {
            "parse_start", "auto_extract_parser", "normalize_field", "parse_end"
        },
        "statuses": {"success", "fail"},
        "meta_keys": {"parser_version"}
    },
    "validator": {
        "actions": {
            "validate_start", "field_validate_fail", "doc_validate_pass"
        },
        "statuses": {"pass", "fail"},
        "meta_keys": {"validator_version"}
    },
    "labeler": {
        "actions": {
            "ai_extract", "human_label", "human_edit", "approve_doc",
            "reject_doc", "set_track"
        },
        "statuses": {"corrected", "approved", "skipped"},
        "meta_keys": {"model_version", "temperature", "reason", "duration_ms", "review_time_sec"}
    },
    "benchmark": {
        "actions": set(),  # Define if needed
        "statuses": set(),  # Define if needed
        "meta_keys": {"reason", "duration_ms"}
    }
}

def validate_log_entry(entry: dict) -> bool:
    # Basic type checks
    required_fields = {
        "timestamp": str,
        "doc_id": str,
        "run_id": str,
        "role": str,
        "actor": str,
        "action": str,
        "field": (str, type(None)),
        "from": (str, type(None)),
        "to": (str, type(None)),
        "status": (str, type(None)),
        "schema_version": str,
        "meta": dict
    }

    for key, expected_type in required_fields.items():
        if key not in entry:
            print(f"Missing key: {key}")
            return False
        if isinstance(expected_type, tuple):
            if not isinstance(entry[key], expected_type):
                print(f"Invalid type for key '{key}': expected {expected_type}, got {type(entry[key])}")
                return False
        else:
            if not isinstance(entry[key], expected_type):
                print(f"Invalid type for key '{key}': expected {expected_type}, got {type(entry[key])}")
                return False

    # Role-specific validation
    role = entry["role"]
    if role not in ROLE_ACTIONS:
        print(f"Invalid role: {role}")
        return False

    if entry["action"] not in ROLE_ACTIONS[role]["actions"]:
        print(f"Invalid action '{entry['action']}' for role '{role}'")
        return False

    if entry["status"] and entry["status"] not in ROLE_ACTIONS[role]["statuses"]:
        print(f"Invalid status '{entry['status']}' for role '{role}'")
        return False

    # Field logic
    if entry["field"] is None:
        if entry["from"] is not None or entry["to"] is not None:
            print("Field is null but 'from' or 'to' is not null")
            return False

    # Meta keys
    allowed_meta_keys = ROLE_ACTIONS[role]["meta_keys"]
    for key in entry["meta"]:
        if key not in allowed_meta_keys:
            print(f"Unexpected meta key '{key}' for role '{role}'")
            return False

    return True

def audit_log(
    doc_id: str,
    role: str,
    actor: str,
    action: str,
    run_id: str = None,
    field: str = None,
    from_value: str = None,
    to_value: str = None,
    status: str = None,
    schema_version: str = None,
    meta: dict = None,
    log_file: str = None
):
    if run_id is None:
        run_id = str(uuid.uuid4())

    log_entry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "doc_id": doc_id,
        "run_id": run_id,
        "role": role,
        "actor": actor,
        "action": action,
        "field": field,
        "from": from_value if field else None,
        "to": to_value if field else None,
        "status": status,
        "schema_version": schema_version,
        "meta": meta or {}
    }

    if not validate_log_entry(log_entry):
        raise ValueError("Log entry does not conform to schema or role-specific rules.")

    with open(log_file, "a") as f:
        f.write(json.dumps(log_entry) + "\n")

    return log_entry
